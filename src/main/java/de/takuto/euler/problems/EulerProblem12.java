package de.takuto.euler.problems;

import de.takuto.euler.EulerProblem;

/**
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 * <p>
 *  The first ten terms would be:
 * </p>
 * <p>
 *  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * </p>
 * <p>
 *  Let us list the factors of the first seven triangle numbers:
 * </p>
 * <p>
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 *  10: 1,2,5,10
 *  15: 1,3,5,15
 *  21: 1,3,7,21
 *  28: 1,2,4,7,14,28
 *</p>
 * <p>
 *  We can see that 28 is the first triangle number to have over five divisors.
 *  What is the value of the first triangle number to have over five hundred divisors?
 * </p>
 */
public class EulerProblem12 implements EulerProblem {

    private final static int NUM_OF_DIVISORS_TO_FIND = 500;

    public String solve() {
        var num = 0;
        var triangleNumberVal = 1;
        var counter = 1;
        while(num < NUM_OF_DIVISORS_TO_FIND) {
            triangleNumberVal = getNthTriangle(counter);
            num = getDivisorCount(triangleNumberVal);
            counter++;
        }
        return "The first triangle number to have more than " + NUM_OF_DIVISORS_TO_FIND + " divisors is: " + triangleNumberVal;
    }

    public int getNumber() {
        return 12;
    }

    /**
     * Returns the nth triangle number.
     * e.g. if n is 3 then return 1 + 2 + 3 = 6
     *
     * @param n The nth triangle number
     * @return The nth triangle number
     */
    private int getNthTriangle(final int n) {
        return n * (n + 1 ) / 2;
    }

    /**
     * Returns the number of divisors of the given number
     * @param n The number to count their divisors
     * @return The divisor count
     */
    private int getDivisorCount(final int n) {
        var divisorCount = 0;
        var currentDivider = 1;
        var biggestKnownDivider = 0;
        do {
            if(n % currentDivider == 0) {
                divisorCount += 2;
                biggestKnownDivider = n / currentDivider;
            }
            currentDivider++;
        } while(currentDivider < biggestKnownDivider);

        return divisorCount;
    }
}
